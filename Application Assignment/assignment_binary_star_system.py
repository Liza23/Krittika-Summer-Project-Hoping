# -*- coding: utf-8 -*-
"""Assignment|Binary Star System.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1m6VBliAnTiHKS-PMdf7arbYG5y66poc-

Packages
"""

import numpy as np
import pandas as pd
from scipy.optimize import curve_fit as cf
import matplotlib.pyplot as plt

"""Load data"""

from google.colab import files
uploaded = files.upload()

import io
data = io.BytesIO(uploaded['Binary_data 2.csv'])

import pandas as pd   
data = pd.read_csv('Binary_Data 2.csv', header=2)

data

"""Extracting data from the csv file"""

time=data['#time']
redshift_star1=data['redshift1']
redshift_star2=data['redshift2']

time

redshift_star1

redshift_star2

plt.scatter(time,redshift_star1,color='r')
plt.xlabel('time')
plt.ylabel('redshift_star1')
plt.title('Redshift of star 1')

plt.scatter(time,redshift_star2,color='r')
plt.xlabel('time')
plt.ylabel('redshift_star2')
plt.title('Redshift of star 2')

"""Calculating orbital velocities"""

c=3.0e8 #speed of light

# Orbital velocity for star 1 calculated over all years
# Here cos theta is assumed to be 1 since the orbital plane
# of the system is assumed to be parallel to the line of sight 
v1=[]
for z in redshift_star1:
  v1.append(z*c)

print(v1)

plt.scatter(time,v1,color='green')
plt.xlabel('time')
plt.ylabel('v1')
plt.title('Orbital velocity of star 1')

# Orbital velocity for star 2 calculated over all years
# Here cos theta is assumed to be 1 since the orbital plane
# of the system is assumed to be parallel to the line of sight 
v2=[]
for z in redshift_star2:
  v2.append(z*c)

print(v2)

plt.scatter(time,v2,color='orange')
plt.xlabel('time')
plt.ylabel('v2')
plt.title('Orbital velocity of star 2')

#We use the formula v_cm=2v1v2/v1+v2 as derived in the derivation portion.
v_cm=[]
for i in range(1000):
  v_cm.append((2*v1[i]*v2[i])/(v1[i]+v2[i]))

print(v_cm)

plt.scatter(time,v_cm,color='yellow')
plt.xlabel('time')
plt.ylabel('Orbital velocity of center of mass')
plt.title('Orbital velocity of center of mass')

"""Fitting the curve"""

pi=3.141592653589793238
def sine(x,a,b,c):
  rad=float(x)*pi/180.0
  return np.sin(a*rad+b)+c

f2 = np.vectorize(sine)

v_cm=np.array(v_cm)
ydata = f2 (v_cm,0.2,0.2,0.0) + 0.2*np.random.randn(len(v_cm))

plt.scatter(v_cm,ydata,s=1)
plt.xlabel('Orbital velocity')
plt.ylabel('Sine of Orbital velocity')
plt.title('Sine Curve Fitting')

print(len(v_cm))
print(len(ydata))

p_opt, p_cov = cf(f2,v_cm,ydata,p0=[0.2,0.2,0])

p_cov

plt.plot(v_cm,f2(v_cm,*p_opt),label='Best Fit',color='lightpink')
plt.scatter(v_cm,ydata,label='OG_Data',s=1,color='darkviolet')
plt.xlabel('Orbital Velocity')
plt.ylabel('Sine of Orbital Velocity')
plt.title('Sine Fitting')
plt.legend()

"""Calculation part"""

#For Star 1

#let us take the reading at time t=1 year
wavelength_observed_1=650e-9  #assumed as data is given in balmer region

wavelength_emitted_1=wavelength_observed_1/(1+redshift_star1[1])
print(wavelength_emitted_1)

time_period_1=wavelength_emitted_1/c
print(time_period_1)

#from the derivation portion
G= 6.67259e-11
mass_1=(time_period_1*v2[1]*(v1[1]+v2[1])*(v1[1]+v2[1]))/2*G*pi

#For Star 2

#let us take the reading at time t=1 year
wavelength_observed_2=650e-9  #assumed as data is given in balmer region

wavelength_emitted_2=wavelength_observed_2/(1+redshift_star2[1])
print(wavelength_emitted_2)

time_period_2=wavelength_emitted_2/c
print(time_period_2)

#from the derivation portion
G= 6.67259e-11
mass_2=(time_period_2*v1[1]*(v1[1]+v2[1])*(v1[1]+v2[1]))/2*G*pi

#Notice time period of both stars is equal